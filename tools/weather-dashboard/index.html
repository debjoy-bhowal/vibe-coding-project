<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Dashboard - Vibe Coding</title>
    <meta name="description" content="Real-time weather dashboard with forecasts and interactive maps">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- DaisyUI -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.9.4/dist/full.css" rel="stylesheet" type="text/css" />
    
    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Chart.js for weather charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Leaflet.js for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Custom CSS -->
    <style>
        .weather-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.2));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .sunny { background: linear-gradient(135deg, #FFD700, #FFA500); }
        .cloudy { background: linear-gradient(135deg, #87CEEB, #4682B4); }
        .rainy { background: linear-gradient(135deg, #4682B4, #2F4F4F); }
        .snowy { background: linear-gradient(135deg, #F0F8FF, #B0C4DE); }
        .stormy { background: linear-gradient(135deg, #2F4F4F, #1C1C1C); }
        .default-weather { background: linear-gradient(135deg, #87CEEB, #4682B4); }
        
        .weather-icon {
            font-size: 4rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .forecast-card {
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(5px);
            transition: transform 0.2s ease;
        }
        
        .forecast-card:hover {
            transform: translateY(-2px);
        }
        
        .search-container {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
        }
        
        .loading-spinner {
            border: 3px solid #f3f3f4;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .weather-metric {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .chart-container {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
        }
        
        .weather-map {
            height: 400px;
            border-radius: 0.5rem;
            overflow: hidden;
            background: #f5f5f5;
            position: relative;
        }
        
        .weather-map::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid #e5e7eb;
            border-top: 3px solid #8B5CF6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 1000;
            display: none;
        }
        
        .weather-map.loading::before {
            display: block;
        }
        
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(255,255,255,0.9);
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .map-controls select {
            border: none;
            background: none;
            font-size: 12px;
        }
        
        /* Leaflet tile loading improvements */
        .leaflet-tile-container {
            background: #f9fafb;
        }
        
        .leaflet-tile {
            transition: opacity 0.2s ease-in-out;
        }
        
        /* Custom tooltip styling */
        .weather-overlay-tooltip {
            background: rgba(0, 0, 0, 0.9) !important;
            color: white !important;
            border: none !important;
            border-radius: 8px !important;
            font-size: 12px !important;
            padding: 12px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
            min-width: 120px !important;
        }
        
        .weather-overlay-tooltip .leaflet-tooltip-content {
            margin: 0 !important;
        }
        
        /* Weather data icon styling */
        .weather-data-icon {
            background: none !important;
            border: none !important;
            transition: transform 0.2s ease-in-out;
        }
        
        .weather-data-icon:hover {
            transform: scale(1.1);
        }
        
        /* Map error handling */
        .leaflet-tile-error {
            background: linear-gradient(45deg, #f3f4f6 25%, transparent 25%), 
                        linear-gradient(-45deg, #f3f4f6 25%, transparent 25%), 
                        linear-gradient(45deg, transparent 75%, #f3f4f6 75%), 
                        linear-gradient(-45deg, transparent 75%, #f3f4f6 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #e5e7eb;
        }
    </style>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#8B5CF6',
                        secondary: '#06B6D4',
                    }
                }
            }
        }
    </script>
</head>
<body class="min-h-screen" x-data="weatherApp()" :class="getBackgroundClass()">
    
    <!-- Header -->
    <header class="bg-white/80 backdrop-blur-md shadow-lg sticky top-0 z-50">
        <div class="container mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-4">
                    <a href="../../" class="btn btn-ghost gap-2 hover:text-primary">
                        <i class="fas fa-arrow-left"></i>
                        <span class="hidden md:inline">Back to Hub</span>
                    </a>
                    <div class="divider divider-horizontal hidden md:flex"></div>
                    <h1 class="text-lg md:text-2xl font-bold text-gray-800">
                        <i class="fas fa-cloud-sun text-primary text-lg md:text-xl"></i>
                        <span class="hidden xs:inline">Weather</span> <span class="hidden sm:inline">Dashboard</span><span class="xs:hidden">☀️</span>
                    </h1>
                </div>
                <div class="flex items-center gap-1 md:gap-2">
                    <button @click="toggleUnit()" class="btn btn-ghost btn-xs md:btn-sm">
                        <span x-text="tempUnit === 'C' ? '°C' : '°F'"></span>
                    </button>
                    <button @click="getCurrentLocation()" class="btn btn-ghost btn-xs md:btn-sm" :disabled="loading">
                        <i class="fas fa-location-dot"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Search Section -->
    <div class="container mx-auto px-4 py-6">
        <div class="search-container rounded-lg shadow-lg p-6 mb-6">
            <div class="flex flex-col md:flex-row gap-4">
                <div class="flex-1">
                    <div class="form-control">
                        <div class="input-group">
                            <input 
                                type="text" 
                                placeholder="Enter city name..." 
                                class="input input-bordered flex-1"
                                x-model="searchCity"
                                x-ref="searchInput"
                                @keyup.enter="searchWeather()"
                                :disabled="loading">
                            <button 
                                class="btn btn-primary" 
                                @click="searchWeather()"
                                :disabled="loading || !searchCity.trim()">
                                <i class="fas fa-search" x-show="!loading"></i>
                                <div class="loading-spinner" x-show="loading"></div>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="flex gap-2">
                    <button @click="addToFavorites()" class="btn btn-outline" :disabled="!currentWeather.city">
                        <i class="fas fa-heart"></i>
                        Favorite
                    </button>
                    <div class="dropdown dropdown-end">
                        <label tabindex="0" class="btn btn-outline">
                            <i class="fas fa-star"></i>
                            Favorites
                        </label>
                        <ul tabindex="0" class="dropdown-content menu p-2 shadow bg-base-100 rounded-box w-52">
                            <template x-for="city in favorites" :key="city">
                                <li>
                                    <a @click="loadFavoriteWeather(city)" x-text="city"></a>
                                </li>
                            </template>
                            <li x-show="favorites.length === 0">
                                <span class="text-gray-500">No favorites yet</span>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Message -->
    <div class="container mx-auto px-4" x-show="error">
        <div class="alert alert-error mb-6">
            <i class="fas fa-exclamation-triangle"></i>
            <span x-text="error"></span>
        </div>
    </div>

    <!-- Current Weather -->
    <div class="container mx-auto px-4 pb-6" x-show="currentWeather.city">
        <div class="weather-card rounded-2xl shadow-2xl p-8 mb-8 text-white">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 items-center">
                
                <!-- Main Weather Info -->
                <div class="text-center lg:text-left">
                    <h2 class="text-3xl font-bold mb-2" x-text="currentWeather.city"></h2>
                    <p class="text-lg opacity-90 mb-4" x-text="formatDate(new Date())"></p>
                    <div class="flex items-center justify-center lg:justify-start gap-4">
                        <i :class="getWeatherIcon(currentWeather.condition)" class="weather-icon"></i>
                        <div>
                            <div class="text-5xl font-bold" x-text="formatTemp(currentWeather.temp)"></div>
                            <div class="text-xl capitalize" x-text="currentWeather.condition"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Weather Metrics -->
                <div class="grid grid-cols-2 gap-4">
                    <div class="weather-metric rounded-lg p-4 text-center">
                        <i class="fas fa-eye text-2xl mb-2"></i>
                        <div class="text-sm opacity-75">Visibility</div>
                        <div class="text-lg font-semibold" x-text="currentWeather.visibility + ' km'"></div>
                    </div>
                    <div class="weather-metric rounded-lg p-4 text-center">
                        <i class="fas fa-droplet text-2xl mb-2"></i>
                        <div class="text-sm opacity-75">Humidity</div>
                        <div class="text-lg font-semibold" x-text="currentWeather.humidity + '%'"></div>
                    </div>
                    <div class="weather-metric rounded-lg p-4 text-center">
                        <i class="fas fa-wind text-2xl mb-2"></i>
                        <div class="text-sm opacity-75">Wind Speed</div>
                        <div class="text-lg font-semibold" x-text="currentWeather.windSpeed + ' km/h'"></div>
                    </div>
                    <div class="weather-metric rounded-lg p-4 text-center">
                        <i class="fas fa-thermometer-half text-2xl mb-2"></i>
                        <div class="text-sm opacity-75">Feels Like</div>
                        <div class="text-lg font-semibold" x-text="formatTemp(currentWeather.feelsLike)"></div>
                    </div>
                </div>
                
                <!-- Additional Info -->
                <div class="space-y-4">
                    <div class="weather-metric rounded-lg p-4">
                        <div class="flex justify-between items-center">
                            <span><i class="fas fa-sun mr-2"></i>Sunrise</span>
                            <span x-text="currentWeather.sunrise"></span>
                        </div>
                    </div>
                    <div class="weather-metric rounded-lg p-4">
                        <div class="flex justify-between items-center">
                            <span><i class="fas fa-moon mr-2"></i>Sunset</span>
                            <span x-text="currentWeather.sunset"></span>
                        </div>
                    </div>
                    <div class="weather-metric rounded-lg p-4">
                        <div class="flex justify-between items-center">
                            <span><i class="fas fa-gauge mr-2"></i>Pressure</span>
                            <span x-text="currentWeather.pressure + ' hPa'"></span>
                        </div>
                    </div>
                    <div class="weather-metric rounded-lg p-4">
                        <div class="flex justify-between items-center">
                            <span><i class="fas fa-arrows-alt-v mr-2"></i>UV Index</span>
                            <span x-text="currentWeather.uvIndex"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 5-Day Forecast -->
    <div class="container mx-auto px-4 pb-6" x-show="forecast.length > 0">
        <h3 class="text-2xl font-bold text-white mb-6 text-center">5-Day Forecast</h3>
        <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-8">
            <template x-for="day in forecast" :key="day.date">
                <div class="forecast-card rounded-lg p-4 text-center shadow-lg">
                    <div class="text-sm font-semibold mb-2" x-text="formatForecastDate(day.date)"></div>
                    <i :class="getWeatherIcon(day.condition)" class="text-3xl mb-2 text-blue-600"></i>
                    <div class="text-lg font-bold text-gray-800" x-text="formatTemp(day.temp)"></div>
                    <div class="text-sm text-gray-600" x-text="formatTemp(day.tempMin) + ' / ' + formatTemp(day.tempMax)"></div>
                    <div class="text-xs text-gray-500 mt-1 capitalize" x-text="day.condition"></div>
                    <div class="text-xs text-blue-600 mt-2">
                        <i class="fas fa-droplet mr-1"></i>
                        <span x-text="day.humidity + '%'"></span>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <!-- Hourly Chart -->
    <div class="container mx-auto px-4 pb-6" x-show="hourlyData.length > 0">
        <div class="chart-container p-6 mb-8">
            <h3 class="text-xl font-bold text-gray-800 mb-4">24-Hour Temperature & Humidity</h3>
            <div class="relative h-64 w-full">
                <canvas id="hourlyChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Interactive Weather Map -->
    <div class="container mx-auto px-4 pb-8" x-show="currentWeather.city">
        <div class="chart-container p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">Interactive Weather Map</h3>
                <div class="flex gap-2">
                    <select x-model="mapLayer" @change="updateMapLayer()" class="select select-bordered select-sm">
                        <option value="clouds">Clouds</option>
                        <option value="precipitation">Precipitation</option>
                        <option value="temp">Temperature</option>
                        <option value="wind">Wind</option>
                        <option value="pressure">Pressure</option>
                    </select>
                    <button @click="refreshMap()" class="btn btn-outline btn-sm" title="Refresh map tiles">
                        <i class="fas fa-refresh"></i>
                        Refresh
                    </button>
                    <button @click="centerMapOnLocation()" class="btn btn-primary btn-sm">
                        <i class="fas fa-crosshairs"></i>
                        Center
                    </button>
                </div>
            </div>
            <div class="relative">
                <div id="weatherMap" class="weather-map"></div>
            </div>
            <div class="mt-2 text-sm text-gray-600">
                <p>Interactive map showing <span x-text="mapLayerNames[mapLayer]"></span> data from Open-Meteo API</p>
                <p>Click and drag to pan • Scroll to zoom • Current location: <span x-text="currentWeather.city"></span></p>
                <div x-show="mapLoading" class="flex items-center gap-2 mt-1">
                    <div class="loading-spinner w-4 h-4"></div>
                    <span class="text-xs">Loading real weather data...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div class="container mx-auto px-4 py-20 text-center" x-show="loading">
        <div class="loading-spinner mx-auto mb-4"></div>
        <p class="text-white text-lg">Loading weather data...</p>
    </div>

    <!-- Welcome State -->
    <div class="container mx-auto px-4 py-20 text-center" x-show="!currentWeather.city && !loading">
        <div class="weather-card rounded-2xl p-12 text-white">
            <i class="fas fa-cloud-sun text-6xl mb-6"></i>
            <h2 class="text-3xl font-bold mb-4">Welcome to Weather Dashboard</h2>
            <p class="text-lg mb-6">Get real-time weather data by searching for a city or using your current location</p>
            <div class="flex flex-col sm:flex-row gap-4 justify-center">
                <button @click="getCurrentLocation()" class="btn btn-primary btn-lg">
                    <i class="fas fa-location-dot mr-2"></i>
                    Use My Location
                </button>
                <button @click="$refs.searchInput?.focus()" class="btn btn-outline btn-lg text-white border-white hover:bg-white hover:text-gray-800">
                    <i class="fas fa-search mr-2"></i>
                    Search City
                </button>
            </div>
            <p class="text-sm mt-4 opacity-75">Powered by Open-Meteo API</p>
        </div>
    </div>

    <!-- Toast Notifications -->
    <div class="toast toast-top toast-end z-[60]" x-show="showToast" x-transition>
        <div class="alert" :class="toastType === 'success' ? 'alert-success' : 'alert-error'">
            <i :class="toastType === 'success' ? 'fas fa-check' : 'fas fa-exclamation-triangle'"></i>
            <span x-text="toastMessage"></span>
        </div>
    </div>

    <script src="../../assets/js/utils.js"></script>
    <script>
        function weatherApp() {
            return {
                searchCity: '',
                currentWeather: {},
                forecast: [],
                hourlyData: [],
                favorites: [],
                tempUnit: 'C',
                loading: false,
                error: '',
                showToast: false,
                toastMessage: '',
                toastType: 'success',
                hourlyChart: null,
                weatherMap: null,
                mapLayer: 'clouds',
                currentCoords: null,
                mapLoading: false,
                mapLayerNames: {
                    clouds: 'cloud coverage',
                    precipitation: 'precipitation',
                    temp: 'temperature',
                    wind: 'wind speed',
                    pressure: 'atmospheric pressure'
                },
                
                init() {
                    this.loadFavorites();
                    // Don't auto-call getCurrentLocation() to avoid Chrome geolocation warning
                    // User must click the location button or search manually
                },
                
                async getCurrentLocation() {
                    if (!navigator.geolocation) {
                        this.showError('Geolocation is not supported by this browser');
                        return;
                    }
                    
                    this.loading = true;
                    this.error = '';
                    
                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            const { latitude, longitude } = position.coords;
                            await this.getWeatherByCoords(latitude, longitude);
                        },
                        (error) => {
                            console.error('Geolocation error:', error);
                            this.showError('Unable to access your location. Please search for a city manually.');
                            this.loading = false;
                        }
                    );
                },
                
                async getWeatherByCoords(lat, lon) {
                    try {
                        // Get weather data from Open-Meteo API
                        const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,is_day,precipitation,rain,showers,snowfall,weather_code,cloud_cover,pressure_msl,surface_pressure,wind_speed_10m,wind_direction_10m,wind_gusts_10m&hourly=temperature_2m,relative_humidity_2m,precipitation_probability,weather_code&daily=weather_code,temperature_2m_max,temperature_2m_min,sunrise,sunset,uv_index_max,precipitation_sum,rain_sum,showers_sum,snowfall_sum,precipitation_hours,precipitation_probability_max,wind_speed_10m_max,wind_gusts_10m_max,wind_direction_10m_dominant&timezone=auto&forecast_days=7`);
                        
                        if (!response.ok) {
                            throw new Error('Weather data not available');
                        }
                        
                        const data = await response.json();
                        
                        // Get location name using a different approach since Open-Meteo doesn't support reverse geocoding
                        let cityName = 'Current Location';
                        
                        // Try to get location name from browser's geolocation API or use coordinates
                        try {
                            // Use a free reverse geocoding service or fallback to coordinates display
                            cityName = `Location (${lat.toFixed(3)}, ${lon.toFixed(3)})`;
                            
                            // Optional: Try using a free reverse geocoding service like Nominatim
                            const reverseGeoResponse = await fetch(
                                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&addressdetails=1&extratags=1`
                            );
                            
                            if (reverseGeoResponse.ok) {
                                const geoData = await reverseGeoResponse.json();
                                if (geoData && geoData.display_name) {
                                    // Extract city/town name from the response
                                    const address = geoData.address || {};
                                    const city = address.city || address.town || address.village || address.county;
                                    const state = address.state || address.region;
                                    const country = address.country;
                                    
                                    if (city) {
                                        cityName = city;
                                        if (state && state !== city) cityName += `, ${state}`;
                                        if (country && country !== state) cityName += `, ${country}`;
                                    } else {
                                        // Fallback to display_name but make it shorter
                                        const parts = geoData.display_name.split(',');
                                        cityName = parts.slice(0, 3).join(', ');
                                    }
                                }
                            }
                        } catch (geoError) {
                            console.warn('Reverse geocoding failed:', geoError);
                            // Keep the coordinate-based name as fallback
                        }
                        
                        this.setWeatherDataFromAPI(data, cityName);
                        this.loading = false;
                        
                        // Store coordinates for map
                        this.currentCoords = { lat, lon };
                        this.initializeMap();
                    } catch (error) {
                        console.error('Weather API error:', error);
                        this.showError('Failed to fetch weather data. Please try again.');
                        this.loading = false;
                    }
                },
                
                async searchWeather() {
                    if (!this.searchCity.trim()) return;
                    
                    this.loading = true;
                    this.error = '';
                    
                    try {
                        // Get coordinates for the city using Open-Meteo Geocoding API
                        const geocodingResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(this.searchCity)}&count=1&language=en&format=json`);
                        
                        if (!geocodingResponse.ok) {
                            throw new Error('Geocoding failed');
                        }
                        
                        const geocodingData = await geocodingResponse.json();
                        
                        if (!geocodingData.results || geocodingData.results.length === 0) {
                            throw new Error('City not found');
                        }
                        
                        const location = geocodingData.results[0];
                        const { latitude, longitude } = location;
                        
                        // Get weather data using coordinates
                        const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,apparent_temperature,is_day,precipitation,rain,showers,snowfall,weather_code,cloud_cover,pressure_msl,surface_pressure,wind_speed_10m,wind_direction_10m,wind_gusts_10m&hourly=temperature_2m,relative_humidity_2m,precipitation_probability,weather_code&daily=weather_code,temperature_2m_max,temperature_2m_min,sunrise,sunset,uv_index_max,precipitation_sum,rain_sum,showers_sum,snowfall_sum,precipitation_hours,precipitation_probability_max,wind_speed_10m_max,wind_gusts_10m_max,wind_direction_10m_dominant&timezone=auto&forecast_days=7`);
                        
                        if (!weatherResponse.ok) {
                            throw new Error('Weather data not available');
                        }
                        
                        const weatherData = await weatherResponse.json();
                        
                        // Format city name
                        let cityName = location.name;
                        if (location.admin1) cityName += `, ${location.admin1}`;
                        if (location.country) cityName += `, ${location.country}`;
                        
                        this.setWeatherDataFromAPI(weatherData, cityName);
                        this.searchCity = '';
                        this.loading = false;
                        
                        // Store coordinates for map
                        this.currentCoords = { lat: latitude, lon: longitude };
                        this.initializeMap();
                    } catch (error) {
                        console.error('Search error:', error);
                        this.showError('City not found. Please try again with a different name.');
                        this.loading = false;
                    }
                },
                
                setWeatherDataFromAPI(data, cityName) {
                    const current = data.current;
                    const daily = data.daily;
                    const hourly = data.hourly;
                    
                    // Map weather codes to conditions
                    const weatherCodeToCondition = (code) => {
                        if (code === 0) return 'sunny';
                        if (code >= 1 && code <= 3) return 'cloudy';
                        if ((code >= 51 && code <= 67) || (code >= 80 && code <= 99)) return 'rainy';
                        if (code >= 71 && code <= 77) return 'snowy';
                        if (code >= 95 && code <= 99) return 'stormy';
                        return 'cloudy';
                    };
                    
                    // Set current weather
                    this.currentWeather = {
                        city: cityName,
                        temp: Math.round(current.temperature_2m),
                        condition: weatherCodeToCondition(current.weather_code),
                        humidity: current.relative_humidity_2m,
                        windSpeed: Math.round(current.wind_speed_10m * 3.6), // Convert m/s to km/h
                        visibility: 10, // Open-Meteo doesn't provide visibility, using default
                        feelsLike: Math.round(current.apparent_temperature),
                        pressure: Math.round(current.pressure_msl),
                        uvIndex: daily.uv_index_max[0] || 0,
                        sunrise: this.formatTime(daily.sunrise[0]),
                        sunset: this.formatTime(daily.sunset[0])
                    };
                    
                    // Set 5-day forecast
                    this.forecast = [];
                    for (let i = 1; i <= 5 && i < daily.time.length; i++) {
                        this.forecast.push({
                            date: daily.time[i],
                            temp: Math.round((daily.temperature_2m_max[i] + daily.temperature_2m_min[i]) / 2),
                            tempMin: Math.round(daily.temperature_2m_min[i]),
                            tempMax: Math.round(daily.temperature_2m_max[i]),
                            condition: weatherCodeToCondition(daily.weather_code[i]),
                            humidity: Math.round(
                                hourly.relative_humidity_2m
                                    .slice(i * 24, (i + 1) * 24)
                                    .reduce((sum, val) => sum + val, 0) / 24
                            )
                        });
                    }
                    
                    // Set hourly data for today (next 24 hours)
                    this.hourlyData = [];
                    const currentHour = new Date().getHours();
                    for (let i = 0; i < 24; i++) {
                        const hourIndex = currentHour + i < 24 ? currentHour + i : currentHour + i - 24;
                        const dataIndex = i < (24 - currentHour) ? i : i + 24;
                        
                        this.hourlyData.push({
                            hour: hourIndex,
                            temp: Math.round(hourly.temperature_2m[dataIndex] || current.temperature_2m),
                            humidity: Math.round(hourly.relative_humidity_2m[dataIndex] || current.relative_humidity_2m)
                        });
                    }
                    
                    this.updateChart();
                },
                
                formatTime(isoString) {
                    const date = new Date(isoString);
                    return date.toLocaleTimeString('en-US', { 
                        hour: '2-digit', 
                        minute: '2-digit',
                        hour12: false 
                    });
                },
                
                updateChart() {
                    this.$nextTick(() => {
                        const ctx = document.getElementById('hourlyChart');
                        if (!ctx) return;
                        
                        if (this.hourlyChart) {
                            this.hourlyChart.destroy();
                        }
                        
                        this.hourlyChart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: this.hourlyData.map(d => d.hour + ':00'),
                                datasets: [{
                                    label: `Temperature (°${this.tempUnit})`,
                                    data: this.hourlyData.map(d => this.tempUnit === 'C' ? d.temp : (d.temp * 9/5) + 32),
                                    borderColor: '#8B5CF6',
                                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                                    fill: true,
                                    tension: 0.4,
                                    yAxisID: 'y'
                                }, {
                                    label: 'Humidity (%)',
                                    data: this.hourlyData.map(d => d.humidity),
                                    borderColor: '#06B6D4',
                                    backgroundColor: 'rgba(6, 182, 212, 0.1)',
                                    fill: true,
                                    tension: 0.4,
                                    yAxisID: 'y1'
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    intersect: false,
                                    mode: 'index'
                                },
                                scales: {
                                    y: {
                                        type: 'linear',
                                        display: true,
                                        position: 'left',
                                        title: {
                                            display: true,
                                            text: `Temperature (°${this.tempUnit})`
                                        }
                                    },
                                    y1: {
                                        type: 'linear',
                                        display: true,
                                        position: 'right',
                                        title: {
                                            display: true,
                                            text: 'Humidity (%)'
                                        },
                                        grid: {
                                            drawOnChartArea: false,
                                        },
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: true,
                                        position: 'top'
                                    }
                                }
                            }
                        });
                    });
                },
                
                initializeMap() {
                    if (!this.currentCoords) return;
                    
                    this.$nextTick(() => {
                        const mapContainer = document.getElementById('weatherMap');
                        if (!mapContainer) return;
                        
                        // Clear existing map
                        if (this.weatherMap) {
                            this.weatherMap.remove();
                        }
                        
                        // Initialize map with error handling
                        this.weatherMap = L.map('weatherMap', {
                            maxZoom: 18,
                            minZoom: 2,
                            worldCopyJump: true,
                            zoomControl: true
                        }).setView([this.currentCoords.lat, this.currentCoords.lon], 10);
                        
                        // Primary tile layer with error handling
                        const primaryTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '© OpenStreetMap contributors',
                            maxZoom: 19,
                            crossOrigin: true,
                            errorTileUrl: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgZmlsbD0iI2Y1ZjVmNSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSIjOTk5Ij5NYXAgVGlsZSBOb3QgQXZhaWxhYmxlPC90ZXh0Pjwvc3ZnPg=='
                        });
                        
                        // Fallback tile layers
                        const fallbackLayers = [
                            L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                                attribution: '© OpenTopoMap contributors',
                                maxZoom: 17
                            }),
                            L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
                                attribution: '© CartoDB contributors',
                                maxZoom: 19,
                                subdomains: 'abcd'
                            }),
                            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                                attribution: '© CartoDB contributors',
                                maxZoom: 19,
                                subdomains: 'abcd'
                            })
                        ];
                        
                        let currentLayerIndex = 0;
                        let retryCount = 0;
                        const maxRetries = 3;
                        
                        // Function to switch to fallback layer
                        const switchToFallback = () => {
                            if (currentLayerIndex < fallbackLayers.length) {
                                console.log(`Switching to fallback tile layer ${currentLayerIndex + 1}`);
                                this.weatherMap.removeLayer(primaryTileLayer);
                                fallbackLayers[currentLayerIndex].addTo(this.weatherMap);
                                currentLayerIndex++;
                                retryCount = 0;
                            }
                        };
                        
                        // Handle tile load errors
                        primaryTileLayer.on('tileerror', (e) => {
                            console.warn('Tile load error:', e);
                            retryCount++;
                            
                            if (retryCount >= maxRetries) {
                                switchToFallback();
                            } else {
                                // Retry loading the tile after a short delay
                                setTimeout(() => {
                                    const tile = e.tile;
                                    const originalSrc = tile.src;
                                    tile.src = '';
                                    setTimeout(() => {
                                        tile.src = originalSrc;
                                    }, 1000);
                                }, 500);
                            }
                        });
                        
                        // Handle successful tile loads
                        primaryTileLayer.on('tileload', () => {
                            retryCount = 0; // Reset retry count on successful load
                        });
                        
                        // Add primary layer to map
                        primaryTileLayer.addTo(this.weatherMap);
                        
                        // Add map loading indicator
                        this.weatherMap.on('movestart', () => {
                            const mapElement = document.getElementById('weatherMap');
                            if (mapElement) {
                                mapElement.style.cursor = 'wait';
                            }
                        });
                        
                        this.weatherMap.on('moveend', () => {
                            const mapElement = document.getElementById('weatherMap');
                            if (mapElement) {
                                mapElement.style.cursor = '';
                            }
                        });
                        
                        // Add zoom event listener to update overlay radius with debouncing
                        let zoomTimeout;
                        this.weatherMap.on('zoomend', () => {
                            // Clear any existing timeout
                            if (zoomTimeout) {
                                clearTimeout(zoomTimeout);
                            }
                            
                            // Debounce the radius update to prevent rapid calls
                            zoomTimeout = setTimeout(() => {
                                this.updateOverlayRadiusOnZoom();
                            }, 150);
                        });
                        
                        // Also handle zoom start to prevent updates during zooming
                        this.weatherMap.on('zoomstart', () => {
                            if (zoomTimeout) {
                                clearTimeout(zoomTimeout);
                            }
                        });
                        
                        // Add weather layer
                        this.updateMapLayer();
                        
                        // Add marker for current location
                        L.marker([this.currentCoords.lat, this.currentCoords.lon])
                            .addTo(this.weatherMap)
                            .bindPopup(`<b>${this.currentWeather.city}</b><br/>
                                       Temperature: ${this.formatTemp(this.currentWeather.temp)}<br/>
                                       Condition: ${this.currentWeather.condition}<br/>
                                       Humidity: ${this.currentWeather.humidity}%`)
                            .openPopup();
                        
                        // Force map resize after initialization
                        setTimeout(() => {
                            this.weatherMap.invalidateSize();
                        }, 100);
                    });
                },
                
                updateMapLayer() {
                    if (!this.weatherMap) return;
                    
                    try {
                        // Remove existing weather overlays (both circles and icons)
                        const layersToRemove = [];
                        
                        this.weatherMap.eachLayer((layer) => {
                            if (layer instanceof L.Rectangle && layer.getTooltip) {
                                layersToRemove.push(layer);
                            }
                            if (layer instanceof L.Circle && layer._weatherOverlay) {
                                layersToRemove.push(layer);
                            }
                            if (layer instanceof L.Marker && layer._weatherOverlay) {
                                layersToRemove.push(layer);
                            }
                        });
                        
                        // Remove layers safely
                        layersToRemove.forEach(layer => {
                            try {
                                if (layer._map) {
                                    this.weatherMap.removeLayer(layer);
                                }
                                // Clean up custom properties
                                if (layer._weatherOverlay) {
                                    delete layer._weatherOverlay;
                                }
                                if (layer._baseRadius) {
                                    delete layer._baseRadius;
                                }
                            } catch (removeError) {
                                console.warn('Error removing layer:', removeError);
                            }
                        });
                        
                        // Wait for map to be ready
                        if (!this.weatherMap.getBounds) {
                            setTimeout(() => this.updateMapLayer(), 100);
                            return;
                        }
                        
                        this.loadRealWeatherOverlay();
                    } catch (error) {
                        console.warn('Error updating map layer:', error);
                    }
                },
                
                async loadRealWeatherOverlay() {
                    if (!this.weatherMap || !this.currentCoords) return;
                    
                    this.mapLoading = true;
                    
                    try {
                        // Get current map center for the single API call
                        const center = this.weatherMap.getCenter();
                        
                        // Fetch comprehensive weather data in a single API call
                        const weatherData = await this.fetchComprehensiveWeatherData(center.lat, center.lng);
                        
                        if (!weatherData) {
                            throw new Error('No weather data could be loaded');
                        }
                        
                        // Create visualization grid using the single data point but with variations
                        this.createWeatherGrid(weatherData, center);
                        
                        console.log('Loaded comprehensive weather data with single API call');
                        
                    } catch (error) {
                        console.warn('Error loading real weather overlay:', error);
                        // Fallback to demo overlay
                        this.addFallbackOverlay();
                    } finally {
                        this.mapLoading = false;
                    }
                },
                
                async fetchComprehensiveWeatherData(lat, lng) {
                    try {
                        // Single API call requesting all weather parameters we need
                        const response = await fetch(
                            `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current=temperature_2m,relative_humidity_2m,cloud_cover,precipitation,wind_speed_10m,wind_direction_10m,pressure_msl,visibility,uv_index&hourly=temperature_2m,relative_humidity_2m,cloud_cover,precipitation,wind_speed_10m,pressure_msl&timezone=auto&forecast_days=1`
                        );
                        
                        if (!response.ok) return null;
                        
                        const data = await response.json();
                        
                        // Return both current and hourly data for variations
                        return {
                            current: data.current,
                            hourly: data.hourly
                        };
                    } catch (error) {
                        console.warn('Error fetching comprehensive weather data:', error);
                        return null;
                    }
                },
                
                createWeatherGrid(weatherData, center) {
                    if (!this.weatherMap || !weatherData) return;
                    
                    const bounds = this.weatherMap.getBounds();
                    const gridSize = 5;
                    const latRange = bounds.getNorth() - bounds.getSouth();
                    const lngRange = bounds.getEast() - bounds.getWest();
                    
                    // Use current weather as base and hourly data to create variations
                    const current = weatherData.current;
                    const hourly = weatherData.hourly;
                    
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = 0; j < gridSize; j++) {
                            const lat = bounds.getSouth() + (latRange * i / (gridSize - 1));
                            const lng = bounds.getWest() + (lngRange * j / (gridSize - 1));
                            
                            // Create realistic variations using hourly data
                            const hourIndex = Math.min(Math.floor((i + j) / 2), hourly.temperature_2m.length - 1);
                            
                            // Calculate distance from center for variation scaling
                            const distanceFromCenter = Math.sqrt(
                                Math.pow((lat - center.lat) * 111000, 2) + 
                                Math.pow((lng - center.lng) * 111000 * Math.cos(lat * Math.PI / 180), 2)
                            ) / 1000; // Convert to km
                            
                            // Create variations based on distance and hourly data
                            const tempVariation = (hourly.temperature_2m[hourIndex] - current.temperature_2m) * 0.5;
                            const cloudVariation = (hourly.cloud_cover[hourIndex] - current.cloud_cover) * 0.3;
                            const precipVariation = Math.max(0, (hourly.precipitation[hourIndex] || 0) + (Math.random() - 0.5) * 2);
                            const windVariation = (hourly.wind_speed_10m[hourIndex] - current.wind_speed_10m) * 0.4;
                            const pressureVariation = (hourly.pressure_msl[hourIndex] - current.pressure_msl) * 0.2;
                            
                            // Create synthetic weather data with realistic variations
                            const syntheticData = {
                                temperature_2m: current.temperature_2m + tempVariation + (Math.random() - 0.5) * 3,
                                cloud_cover: Math.max(0, Math.min(100, current.cloud_cover + cloudVariation + (Math.random() - 0.5) * 20)),
                                precipitation: Math.max(0, current.precipitation + precipVariation),
                                wind_speed_10m: Math.max(0, current.wind_speed_10m + windVariation + (Math.random() - 0.5) * 5),
                                pressure_msl: current.pressure_msl + pressureVariation + (Math.random() - 0.5) * 10,
                                relative_humidity_2m: Math.max(0, Math.min(100, current.relative_humidity_2m + (Math.random() - 0.5) * 15))
                            };
                            
                            // Add the weather data point to the map
                            this.addWeatherDataPoint({ lat, lng }, syntheticData, true);
                        }
                    }
                },
                
                addWeatherDataPoint(point, weatherData, isSynthetic = false) {
                    if (!this.weatherMap || !weatherData) return;
                    
                    let value, color, baseRadius, icon, iconSize;
                    
                    // Map different weather parameters to visual properties
                    switch (this.mapLayer) {
                        case 'temp':
                            value = Math.round(weatherData.temperature_2m * 10) / 10;
                            color = this.getTemperatureColor(value);
                            baseRadius = Math.max(50, Math.abs(value) * 3 + 100);
                            icon = this.getTemperatureIcon(value);
                            iconSize = 16;
                            break;
                        case 'clouds':
                            value = Math.round(weatherData.cloud_cover);
                            color = this.getCloudColor(value);
                            baseRadius = (value / 100) * 150 + 80;
                            icon = this.getCloudIcon(value);
                            iconSize = 18;
                            break;
                        case 'precipitation':
                            value = Math.round(weatherData.precipitation * 100) / 100;
                            color = this.getPrecipitationColor(value);
                            baseRadius = Math.max(60, value * 30 + 90);
                            icon = this.getPrecipitationIcon(value);
                            iconSize = 16;
                            break;
                        case 'wind':
                            value = Math.round(weatherData.wind_speed_10m * 10) / 10;
                            color = this.getWindColor(value);
                            baseRadius = (value / 30) * 120 + 70;
                            icon = this.getWindIcon(value);
                            iconSize = 16;
                            break;
                        case 'pressure':
                            value = Math.round(weatherData.pressure_msl);
                            color = this.getPressureColor(value);
                            baseRadius = Math.abs(value - 1013) * 2 + 85;
                            icon = this.getPressureIcon(value);
                            iconSize = 16;
                            break;
                        default:
                            return;
                    }
                    
                    // Get current zoom level and adjust radius accordingly
                    const currentZoom = this.weatherMap.getZoom();
                    const radius = this.getZoomAdjustedRadius(baseRadius, currentZoom);
                    
                    // Create circle overlay for the data point with zoom-responsive radius
                    const circle = L.circle([point.lat, point.lng], {
                        color: color,
                        fillColor: color,
                        fillOpacity: isSynthetic ? 0.2 : 0.3,
                        radius: radius,
                        weight: 2,
                        opacity: isSynthetic ? 0.7 : 0.9
                    });
                    
                    circle._weatherOverlay = true;
                    circle._baseRadius = baseRadius; // Store base radius for zoom updates
                    circle.addTo(this.weatherMap);
                    
                    // Create custom icon with FontAwesome
                    const customIcon = L.divIcon({
                        html: `<div style="
                            background: ${color}; 
                            border: 2px solid white; 
                            border-radius: 50%; 
                            width: 32px; 
                            height: 32px; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                            font-size: ${iconSize}px;
                            color: ${this.getIconTextColor(color)};
                        ">
                            <i class="${icon}"></i>
                        </div>`,
                        className: 'weather-data-icon',
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    });
                    
                    // Add icon marker
                    const iconMarker = L.marker([point.lat, point.lng], {
                        icon: customIcon,
                        zIndexOffset: 1000
                    });
                    
                    iconMarker._weatherOverlay = true;
                    iconMarker.addTo(this.weatherMap);
                    
                    // Add tooltip with weather data to both circle and icon
                    const unit = this.getWeatherUnit(this.mapLayer);
                    const dataType = isSynthetic ? 'Interpolated' : 'Real-time';
                    
                    const tooltipContent = `
                        <div style="text-align: center;">
                            <strong style="color: ${color};">
                                <i class="${icon}"></i> ${this.mapLayerNames[this.mapLayer]}
                            </strong><br/>
                            <span style="font-size: 14px; font-weight: bold;">${value}${unit}</span><br/>
                            <small style="opacity: 0.8;">${dataType} data</small><br/>
                            <small style="opacity: 0.6;">Lat: ${point.lat.toFixed(3)}, Lng: ${point.lng.toFixed(3)}</small>
                        </div>
                    `;
                    
                    circle.bindTooltip(tooltipContent, {
                        className: 'weather-overlay-tooltip'
                    });
                    
                    iconMarker.bindTooltip(tooltipContent, {
                        className: 'weather-overlay-tooltip'
                    });
                },
                
                addFallbackOverlay() {
                    // Add some demo overlay points if real data fails
                    const center = this.weatherMap.getCenter();
                    const demos = [
                        { 
                            lat: center.lat, 
                            lng: center.lng, 
                            data: {
                                temperature_2m: 22, 
                                cloud_cover: 60, 
                                precipitation: 0.2,
                                wind_speed_10m: 12,
                                pressure_msl: 1015
                            }
                        },
                        { 
                            lat: center.lat + 0.1, 
                            lng: center.lng + 0.1, 
                            data: {
                                temperature_2m: 18, 
                                cloud_cover: 80,
                                precipitation: 1.5,
                                wind_speed_10m: 8,
                                pressure_msl: 1010
                            }
                        },
                        { 
                            lat: center.lat - 0.1, 
                            lng: center.lng - 0.1, 
                            data: {
                                temperature_2m: 25, 
                                cloud_cover: 40,
                                precipitation: 0,
                                wind_speed_10m: 15,
                                pressure_msl: 1020
                            }
                        },
                        { 
                            lat: center.lat + 0.05, 
                            lng: center.lng - 0.05, 
                            data: {
                                temperature_2m: 20, 
                                cloud_cover: 70,
                                precipitation: 0.8,
                                wind_speed_10m: 10,
                                pressure_msl: 1012
                            }
                        }
                    ];
                    
                    demos.forEach(demo => {
                        this.addWeatherDataPoint(
                            { lat: demo.lat, lng: demo.lng }, 
                            demo.data, 
                            false // Mark as demo data
                        );
                    });
                },

                getTemperatureColor(temp) {
                    // Temperature color scale from blue (cold) to red (hot)
                    if (temp < -10) return '#0066cc';
                    if (temp < 0) return '#0099ff';
                    if (temp < 10) return '#00ccff';
                    if (temp < 20) return '#ffff00';
                    if (temp < 30) return '#ff9900';
                    if (temp < 40) return '#ff6600';
                    return '#ff0000';
                },
                
                getTemperatureIcon(temp) {
                    if (temp < 0) return 'fas fa-snowflake';
                    if (temp < 10) return 'fas fa-thermometer-quarter';
                    if (temp < 20) return 'fas fa-thermometer-half';
                    if (temp < 30) return 'fas fa-thermometer-three-quarters';
                    return 'fas fa-thermometer-full';
                },
                
                getCloudColor(cloudCover) {
                    // Cloud coverage from clear (light) to overcast (dark)
                    if (cloudCover < 20) return '#87CEEB';
                    if (cloudCover < 40) return '#708090';
                    if (cloudCover < 60) return '#696969';
                    if (cloudCover < 80) return '#555555';
                    return '#404040';
                },
                
                getCloudIcon(cloudCover) {
                    if (cloudCover < 20) return 'fas fa-sun';
                    if (cloudCover < 40) return 'fas fa-cloud-sun';
                    if (cloudCover < 60) return 'fas fa-cloud';
                    if (cloudCover < 80) return 'fas fa-cloud';
                    return 'fas fa-cloud';
                },
                
                getPrecipitationColor(precipitation) {
                    // Precipitation from light blue to dark blue
                    if (precipitation === 0) return '#E3F2FD';
                    if (precipitation < 1) return '#BBDEFB';
                    if (precipitation < 5) return '#64B5F6';
                    if (precipitation < 10) return '#2196F3';
                    return '#1565C0';
                },
                
                getPrecipitationIcon(precipitation) {
                    if (precipitation === 0) return 'fas fa-eye';
                    if (precipitation < 1) return 'fas fa-cloud-drizzle';
                    if (precipitation < 5) return 'fas fa-cloud-rain';
                    if (precipitation < 10) return 'fas fa-cloud-showers-heavy';
                    return 'fas fa-cloud-bolt-rain';
                },
                
                getWindColor(windSpeed) {
                    // Wind speed from light green to dark green
                    if (windSpeed < 5) return '#E8F5E8';
                    if (windSpeed < 10) return '#C8E6C9';
                    if (windSpeed < 20) return '#81C784';
                    if (windSpeed < 30) return '#4CAF50';
                    return '#2E7D32';
                },
                
                getWindIcon(windSpeed) {
                    if (windSpeed < 5) return 'fas fa-leaf';
                    if (windSpeed < 15) return 'fas fa-wind';
                    if (windSpeed < 25) return 'fas fa-tornado';
                    return 'fas fa-hurricane';
                },
                
                getPressureColor(pressure) {
                    // Pressure from low (purple) to high (orange)
                    if (pressure < 1000) return '#9C27B0';
                    if (pressure < 1010) return '#673AB7';
                    if (pressure < 1020) return '#00BCD4';
                    if (pressure < 1030) return '#FF9800';
                    return '#FF5722';
                },
                
                getPressureIcon(pressure) {
                    if (pressure < 1000) return 'fas fa-arrow-down';
                    if (pressure < 1010) return 'fas fa-arrow-down-right';
                    if (pressure < 1020) return 'fas fa-gauge';
                    if (pressure < 1030) return 'fas fa-arrow-up-right';
                    return 'fas fa-arrow-up';
                },
                
                getIconTextColor(backgroundColor) {
                    // Determine if text should be light or dark based on background
                    const hex = backgroundColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                    return brightness > 128 ? '#333333' : '#ffffff';
                },
                
                getZoomAdjustedRadius(baseRadius, zoomLevel) {
                    // Adjust radius based on zoom level for better visual scaling
                    const zoomFactor = Math.pow(2, zoomLevel - 10); // Base zoom level 10
                    const minRadius = 30;
                    const maxRadius = 300;
                    
                    let adjustedRadius = baseRadius * zoomFactor;
                    
                    // Clamp radius to reasonable bounds
                    adjustedRadius = Math.max(minRadius, Math.min(maxRadius, adjustedRadius));
                    
                    return adjustedRadius;
                },
                
                updateOverlayRadiusOnZoom() {
                    if (!this.weatherMap) return;
                    
                    try {
                        const currentZoom = this.weatherMap.getZoom();
                        
                        // Update all circle overlays with new radius
                        this.weatherMap.eachLayer((layer) => {
                            try {
                                // Check if layer is valid and still on the map
                                if (layer instanceof L.Circle && 
                                    layer._weatherOverlay && 
                                    layer._baseRadius && 
                                    layer._map && 
                                    layer._latlng) {
                                    
                                    const newRadius = this.getZoomAdjustedRadius(layer._baseRadius, currentZoom);
                                    layer.setRadius(newRadius);
                                }
                            } catch (layerError) {
                                // Skip this layer if there's an error
                                console.warn('Error updating layer radius:', layerError);
                            }
                        });
                    } catch (error) {
                        console.warn('Error updating overlay radius on zoom:', error);
                    }
                },
                
                getWeatherUnit(layerType) {
                    const units = {
                        temp: '°C',
                        clouds: '%',
                        precipitation: 'mm',
                        wind: 'm/s',
                        pressure: 'hPa'
                    };
                    return units[layerType] || '';
                },
                
                getLayerColor(layerType) {
                    const colors = {
                        clouds: '#87CEEB',
                        precipitation: '#4682B4',
                        temp: '#FF6B6B',
                        wind: '#98D8C8',
                        pressure: '#A8E6CF'
                    };
                    return colors[layerType] || '#87CEEB';
                },
                
                centerMapOnLocation() {
                    if (this.weatherMap && this.currentCoords) {
                        this.weatherMap.setView([this.currentCoords.lat, this.currentCoords.lon], 10);
                        
                        // Trigger a refresh of tiles
                        this.weatherMap.eachLayer((layer) => {
                            if (layer instanceof L.TileLayer) {
                                layer.redraw();
                            }
                        });
                    }
                },
                
                refreshMap() {
                    if (this.weatherMap) {
                        // Force refresh of all tile layers
                        this.weatherMap.eachLayer((layer) => {
                            if (layer instanceof L.TileLayer) {
                                layer.redraw();
                            }
                        });
                        
                        // Invalidate map size in case of layout changes
                        this.weatherMap.invalidateSize();
                        
                        // Update weather overlay with current zoom level
                        this.updateMapLayer();
                        
                        // Ensure overlay radius is correct for current zoom
                        setTimeout(() => {
                            this.updateOverlayRadiusOnZoom();
                        }, 100);
                        
                        this.showToastMessage('Map refreshed', 'success');
                    }
                },
                
                getWeatherIcon(condition) {
                    const icons = {
                        sunny: 'fas fa-sun text-yellow-400',
                        cloudy: 'fas fa-cloud text-gray-400',
                        rainy: 'fas fa-cloud-rain text-blue-500',
                        snowy: 'fas fa-snowflake text-blue-200',
                        stormy: 'fas fa-bolt text-yellow-300'
                    };
                    return icons[condition] || 'fas fa-cloud text-gray-400';
                },
                
                getBackgroundClass() {
                    if (!this.currentWeather.condition) return 'default-weather';
                    return this.currentWeather.condition;
                },
                
                formatTemp(temp) {
                    if (!temp) return '--°';
                    const converted = this.tempUnit === 'C' ? temp : (temp * 9/5) + 32;
                    return Math.round(converted) + '°' + this.tempUnit;
                },
                
                formatDate(date) {
                    return date.toLocaleDateString('en-US', {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                },
                
                formatForecastDate(dateString) {
                    const date = new Date(dateString);
                    return date.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    });
                },
                
                toggleUnit() {
                    this.tempUnit = this.tempUnit === 'C' ? 'F' : 'C';
                    if (this.hourlyChart) {
                        this.updateChart();
                    }
                },
                
                addToFavorites() {
                    if (!this.currentWeather.city) return;
                    
                    if (!this.favorites.includes(this.currentWeather.city)) {
                        this.favorites.push(this.currentWeather.city);
                        this.saveFavorites();
                        this.showToastMessage('Added to favorites!', 'success');
                    } else {
                        this.showToastMessage('Already in favorites!', 'error');
                    }
                },
                
                async loadFavoriteWeather(city) {
                    this.searchCity = city;
                    await this.searchWeather();
                },
                
                loadFavorites() {
                    const saved = VibeUtils.getStorage('weatherFavorites', []);
                    this.favorites = Array.isArray(saved) ? saved : [];
                },
                
                saveFavorites() {
                    VibeUtils.setStorage('weatherFavorites', this.favorites);
                },
                
                showError(message) {
                    this.error = message;
                    setTimeout(() => {
                        this.error = '';
                    }, 5000);
                },
                
                showToastMessage(message, type = 'success') {
                    this.toastMessage = message;
                    this.toastType = type;
                    this.showToast = true;
                    setTimeout(() => {
                        this.showToast = false;
                    }, 3000);
                },
                
                delay(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }
            }
        }
    </script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    screens: {
                        'xs': '375px',
                    }
                }
            }
        }
    </script>
</body>
</html>
