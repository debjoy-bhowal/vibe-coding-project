<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accessibility Checker - Vibe Tools</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.9.4/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .accessibility-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 10;
            pointer-events: none;
            border-radius: 8px;
        }
        
        .accessibility-overlay.active::before {
            content: "⚠️ Click on any issue's eye icon to highlight specific elements";
            position: absolute;
            top: 15px;
            left: 15px;
            background: #dc2626;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);
            z-index: 20;
            max-width: 300px;
        }
        
        .element-highlight {
            position: absolute;
            border: 3px solid #dc2626;
            background: rgba(220, 38, 38, 0.2);
            pointer-events: none;
            z-index: 15;
            border-radius: 4px;
            animation: element-pulse 2s infinite;
        }
        
        .element-highlight::after {
            content: attr(data-issue);
            position: absolute;
            top: -30px;
            left: 0;
            background: #dc2626;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            white-space: nowrap;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        
        @keyframes element-pulse {
            0%, 100% { 
                opacity: 0.8;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.02);
            }
        }
        
        .highlight-element {
            position: absolute;
            border: 3px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            pointer-events: none;
            animation: highlight-pulse 2s infinite;
        }
        
        @keyframes highlight-pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .contrast-good { color: #10b981; }
        .contrast-warning { color: #f59e0b; }
        .contrast-error { color: #ef4444; }
        
        .report-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .issue-card {
            transition: all 0.3s ease;
        }
        
        .issue-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        .preview-frame {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: white;
            min-height: 400px;
            position: relative;
        }
        
        .loading-spinner {
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-ring {
            transition: stroke-dashoffset 0.5s ease-in-out;
        }
        
        /* Custom modal styles to prevent overflow issues */
        .custom-modal {
            backdrop-filter: blur(4px);
            animation: modal-fade-in 0.2s ease-out;
        }
        
        .custom-modal-content {
            animation: modal-slide-in 0.3s ease-out;
            transform-origin: center;
        }
        
        @keyframes modal-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes modal-slide-in {
            from { 
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to { 
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        /* Ensure body can scroll when modal is open */
        body {
            overflow-y: auto !important;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div x-data="accessibilityChecker()" x-init="init()">
        <!-- Header -->
        <header class="bg-white/80 backdrop-blur-md shadow-lg sticky top-0 z-50">
            <div class="container mx-auto px-4 py-3">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-2 md:gap-4">
                        <a href="../../" class="btn btn-ghost btn-sm gap-1 md:gap-2">
                            <i class="fas fa-arrow-left"></i>
                            <span class="hidden md:inline">Back to Hub</span>
                        </a>
                        <div class="divider divider-horizontal hidden md:flex"></div>
                        <div class="flex items-center gap-1 md:gap-2">
                            <div class="text-xl md:text-3xl">♿</div>
                            <div>
                                <h1 class="text-lg md:text-2xl font-bold text-gray-800">
                                    Accessibility Checker
                                </h1>
                                <p class="text-xs md:text-sm text-gray-600 hidden sm:block">Analyze and improve web accessibility compliance</p>
                            </div>
                        </div>
                    </div>
                    <div class="flex flex-wrap items-center gap-2 hidden lg:flex">
                        <div class="badge badge-primary">WCAG 2.1</div>
                        <div class="badge badge-secondary">Real-time Analysis</div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Alert Component -->
            <div x-show="showAlert" 
                 x-transition:enter="transition ease-out duration-300"
                 x-transition:enter-start="opacity-0 transform -translate-y-2"
                 x-transition:enter-end="opacity-100 transform translate-y-0"
                 x-transition:leave="transition ease-in duration-200"
                 x-transition:leave-start="opacity-100 transform translate-y-0"
                 x-transition:leave-end="opacity-0 transform -translate-y-2"
                 class="alert mb-6"
                 :class="{
                     'alert-error': alertType === 'error',
                     'alert-warning': alertType === 'warning',
                     'alert-info': alertType === 'info',
                     'alert-success': alertType === 'success'
                 }">
                <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.732 15.5c-.77.833.192 2.5 1.732 2.5z" />
                </svg>
                <span x-text="alertMessage"></span>
                <button @click="showAlert = false" class="btn btn-sm btn-circle btn-ghost ml-auto">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <!-- Input Section -->
            <div class="card bg-white shadow-lg mb-8">
                <div class="card-body">
                    <h2 class="card-title text-xl mb-4">
                        <i class="fas fa-search text-blue-500"></i>
                        Analyze Content
                    </h2>
                    
                    <div class="tabs tabs-boxed mb-4">
                        <button class="tab" :class="{'tab-active': inputMode === 'html'}" @click="inputMode = 'html'">
                            <i class="fas fa-code mr-2"></i>HTML Content
                        </button>
                        <button class="tab" :class="{'tab-active': inputMode === 'url'}" @click="inputMode = 'url'">
                            <i class="fas fa-link mr-2"></i>URL
                        </button>
                    </div>

                    <div x-show="inputMode === 'html'">
                        <label class="label" for="html-content">
                            <span class="label-text font-medium">Paste your HTML content:</span>
                        </label>
                        <textarea 
                            id="html-content"
                            x-model="htmlContent" 
                            class="textarea textarea-bordered w-full h-40" 
                            placeholder="<html>...</html>"
                            aria-describedby="html-help"
                        ></textarea>
                        <div id="html-help" class="label">
                            <span class="label-text-alt text-gray-500">Paste the HTML content you want to analyze for accessibility issues</span>
                        </div>
                    </div>

                    <div x-show="inputMode === 'url'">
                        <label class="label" for="url-input">
                            <span class="label-text font-medium">Enter URL to analyze:</span>
                        </label>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <input 
                                id="url-input"
                                x-model="urlInput" 
                                type="url" 
                                class="input input-bordered flex-1" 
                                placeholder="https://example.com"
                                aria-describedby="url-help"
                            />
                            <button @click="fetchFromUrl()" class="btn btn-secondary w-full sm:w-auto" :disabled="!urlInput || isLoading">
                                <i class="fas fa-download mr-2"></i>Fetch
                            </button>
                        </div>
                        <div id="url-help" class="label">
                            <span class="label-text-alt text-gray-500">Note: Due to CORS restrictions, this may not work with all websites</span>
                        </div>
                    </div>

                    <div class="flex justify-center mt-6">
                        <button 
                            @click="analyzeContent()" 
                            class="btn btn-primary btn-lg"
                            :disabled="(!htmlContent && !urlInput) || isLoading"
                        >
                            <div x-show="isLoading" class="loading-spinner mr-2"></div>
                            <i x-show="!isLoading" class="fas fa-play mr-2"></i>
                            <span x-text="isLoading ? 'Analyzing...' : 'Run Accessibility Check'"></span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div x-show="report" class="space-y-6">
                <!-- Overview Cards -->
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div class="card bg-white shadow-lg">
                        <div class="card-body text-center">
                            <div class="text-3xl font-bold" :class="getScoreColor(report?.score || 0)" x-text="report?.score || 0">0</div>
                            <div class="text-sm text-gray-600">Accessibility Score</div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                                <div class="h-2 rounded-full" :class="getScoreColor(report?.score || 0)" :style="`width: ${report?.score || 0}%`"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card bg-white shadow-lg">
                        <div class="card-body text-center">
                            <div class="text-3xl font-bold text-red-500" x-text="report?.issues?.critical || 0">0</div>
                            <div class="text-sm text-gray-600">Critical Issues</div>
                            <div class="badge badge-error mt-2">Must Fix</div>
                        </div>
                    </div>
                    
                    <div class="card bg-white shadow-lg">
                        <div class="card-body text-center">
                            <div class="text-3xl font-bold text-yellow-500" x-text="report?.issues?.warnings || 0">0</div>
                            <div class="text-sm text-gray-600">Warnings</div>
                            <div class="badge badge-warning mt-2">Recommended</div>
                        </div>
                    </div>
                    
                    <div class="card bg-white shadow-lg">
                        <div class="card-body text-center">
                            <div class="text-3xl font-bold text-green-500" x-text="report?.issues?.passed || 0">0</div>
                            <div class="text-sm text-gray-600">Passed Checks</div>
                            <div class="badge badge-success mt-2">Good</div>
                        </div>
                    </div>
                </div>

                <!-- Detailed Report -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <!-- Issues List -->
                    <div class="card bg-white shadow-lg">
                        <div class="card-body">
                            <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-4 gap-4">
                                <h3 class="card-title">
                                    <i class="fas fa-exclamation-triangle text-yellow-500"></i>
                                    Issues Found
                                </h3>
                                <button @click="exportReport()" class="btn btn-sm btn-outline w-full sm:w-auto">
                                    <i class="fas fa-download mr-2"></i>Export Report
                                </button>
                            </div>
                            
                            <div class="space-y-3 max-h-[32rem] overflow-y-auto">
                                <template x-for="issue in report?.detailedIssues || []" :key="issue.id">
                                    <div class="issue-card p-4 border rounded-lg cursor-pointer" @click="showIssueDetail(issue)">
                                        <div class="flex items-start justify-between">
                                            <div class="flex-1">
                                                <div class="flex items-center space-x-2 mb-2">
                                                    <div class="badge" :class="getSeverityBadge(issue.severity)" x-text="issue.severity"></div>
                                                    <span class="font-medium text-sm" x-text="issue.rule"></span>
                                                </div>
                                                <p class="text-gray-700 text-sm mb-2" x-text="issue.description"></p>
                                                <div class="text-xs text-gray-500">
                                                    <i class="fas fa-map-marker-alt mr-1"></i>
                                                    <span x-text="issue.selector"></span>
                                                </div>
                                            </div>
                                            <button class="btn btn-sm btn-ghost" @click.stop="highlightElement(issue)">
                                                <i class="fas fa-eye"></i>
                                            </button>
                                        </div>
                                    </div>
                                </template>
                                
                                <div x-show="!report?.detailedIssues?.length" class="text-center py-8 text-gray-500">
                                    <i class="fas fa-check-circle text-4xl mb-4 text-green-500"></i>
                                    <p>No accessibility issues found!</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- WCAG Checklist -->
                    <div class="card bg-white shadow-lg">
                        <div class="card-body">
                            <h3 class="card-title mb-4">
                                <i class="fas fa-tasks text-blue-500"></i>
                                WCAG 2.1 Checklist
                            </h3>
                            
                            <div class="space-y-3 max-h-[32rem] overflow-y-auto">
                                <template x-for="check in wcagChecklist" :key="check.id">
                                    <div class="flex items-center justify-between p-3 border rounded-lg">
                                        <div class="flex items-center space-x-3">
                                            <div class="form-control">
                                                <input type="checkbox" :checked="check.passed" class="checkbox checkbox-sm" disabled />
                                            </div>
                                            <div>
                                                <p class="font-medium text-sm" x-text="check.title"></p>
                                                <p class="text-xs text-gray-500" x-text="check.description"></p>
                                            </div>
                                        </div>
                                        <div class="badge badge-sm" :class="check.passed ? 'badge-success' : 'badge-error'">
                                            <span x-text="check.passed ? 'Pass' : 'Fail'"></span>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Content Preview -->
                    <div class="card bg-white shadow-lg" x-show="previewContent">
                    <div class="card-body">
                        <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-4 gap-4">
                            <h3 class="card-title">
                                <i class="fas fa-eye text-purple-500"></i>
                                Content Preview
                            </h3>
                            <div class="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
                                <button @click="clearHighlights()" class="btn btn-sm w-full sm:w-auto" :class="highlightedElements.length > 0 ? 'btn-error' : 'btn-outline'" :disabled="highlightedElements.length === 0">
                                    <i class="fas fa-times mr-2"></i>
                                    <span x-text="highlightedElements.length > 0 ? `Clear ${highlightedElements.length} Highlight${highlightedElements.length !== 1 ? 's' : ''}` : 'No Highlights'"></span>
                                </button>
                                <button @click="highlightAllIssues()" class="btn btn-sm btn-warning w-full sm:w-auto" :disabled="!report?.detailedIssues?.length">
                                    <i class="fas fa-layer-group mr-2"></i>
                                    Highlight All Issues
                                </button>
                            </div>
                        </div>                        <div class="preview-frame relative" style="height: 400px;">
                            <iframe 
                                x-ref="previewFrame"
                                class="w-full h-full"
                                title="HTML Content Preview"
                                sandbox="allow-same-origin allow-scripts"
                                srcdoc=""
                                @load="onIframeLoad()"
                            ></iframe>
                            
                            <!-- Overlay container for highlighting specific elements -->
                            <div 
                                x-show="highlightedElements.filter(h => h.visible !== false).length > 0" 
                                class="accessibility-overlay active"
                                x-transition:enter="transition ease-out duration-300"
                                x-transition:enter-start="opacity-0"
                                x-transition:enter-end="opacity-100"
                                x-transition:leave="transition ease-in duration-200"
                                x-transition:leave-start="opacity-100"
                                x-transition:leave-end="opacity-0"
                            >
                                <!-- Individual element highlights -->
                                <template x-for="highlight in highlightedElements.filter(h => h.visible !== false)" :key="highlight.id">
                                    <div 
                                        class="element-highlight"
                                        :style="`left: ${highlight.x}px; top: ${highlight.y}px; width: ${highlight.width}px; height: ${highlight.height}px;`"
                                        :data-issue="highlight.issue"
                                    ></div>
                                </template>
                            </div>
                            
                            <!-- Debug indicator -->
                            <div x-show="highlightedElements.filter(h => h.visible !== false).length > 0" class="absolute top-2 right-2 bg-red-500 text-white px-2 py-1 rounded text-xs">
                                <span x-text="`${highlightedElements.filter(h => h.visible !== false).length} Issue${highlightedElements.filter(h => h.visible !== false).length !== 1 ? 's' : ''} Highlighted`"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Issue Detail Modal -->
        <div x-show="selectedIssue" class="custom-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" x-cloak @click.self="selectedIssue = null">
            <div class="custom-modal-content bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
                <div class="p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-bold">
                            <template x-if="selectedIssue?.rule">
                                <span x-text="selectedIssue.rule"></span>
                            </template>
                            <template x-if="!selectedIssue?.rule">
                                <span>Issue Details</span>
                            </template>
                        </h3>
                        <button @click="selectedIssue = null" class="btn btn-sm btn-circle" aria-label="Close modal">✕</button>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <div class="badge mb-2" :class="getSeverityBadge(selectedIssue?.severity)" x-text="selectedIssue?.severity"></div>
                            <p class="text-gray-700" x-text="selectedIssue?.description"></p>
                        </div>
                        
                        <div>
                            <h4 class="font-medium mb-2">Element:</h4>
                            <code class="bg-gray-100 p-2 rounded block text-sm" x-text="selectedIssue?.selector"></code>
                        </div>
                        
                        <div x-show="selectedIssue?.fix">
                            <h4 class="font-medium mb-2">How to Fix:</h4>
                            <div class="bg-green-50 p-3 rounded border-l-4 border-green-400">
                                <p class="text-green-800 text-sm" x-text="selectedIssue?.fix"></p>
                            </div>
                        </div>
                        
                        <div x-show="selectedIssue?.wcagReference">
                            <h4 class="font-medium mb-2">WCAG Reference:</h4>
                            <a :href="selectedIssue?.wcagReference" target="_blank" class="link link-primary text-sm">
                                Learn more about this guideline
                            </a>
                        </div>
                    </div>
                    
                    <div class="flex justify-end mt-6">
                        <button @click="selectedIssue = null" class="btn btn-primary">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function accessibilityChecker() {
            return {
                inputMode: 'html',
                htmlContent: '',
                urlInput: '',
                isLoading: false,
                report: null,
                previewContent: '',
                showOverlay: false,
                selectedIssue: null,
                highlightedElements: [],
                iframeDocument: null,
                scrollListener: null,
                alertMessage: '',
                alertType: 'error',
                showAlert: false,
                wcagChecklist: [
                    {
                        id: 'alt-text',
                        title: 'Images have alt text',
                        description: 'All images have appropriate alternative text',
                        passed: false
                    },
                    {
                        id: 'headings',
                        title: 'Proper heading structure',
                        description: 'Headings are used correctly and hierarchically',
                        passed: false
                    },
                    {
                        id: 'contrast',
                        title: 'Color contrast',
                        description: 'Text has sufficient contrast ratio (4.5:1 for normal text)',
                        passed: false
                    },
                    {
                        id: 'keyboard',
                        title: 'Keyboard navigation',
                        description: 'All interactive elements are keyboard accessible',
                        passed: false
                    },
                    {
                        id: 'landmarks',
                        title: 'ARIA landmarks',
                        description: 'Page has proper landmark roles and structure',
                        passed: false
                    },
                    {
                        id: 'form-labels',
                        title: 'Form labels',
                        description: 'All form controls have associated labels',
                        passed: false
                    },
                    {
                        id: 'focus-visible',
                        title: 'Focus indicators',
                        description: 'Focus indicators are visible and clear',
                        passed: false
                    },
                    {
                        id: 'lang-attribute',
                        title: 'Language attribute',
                        description: 'Page has lang attribute specified',
                        passed: false
                    }
                ],

                init() {
                    // Set example content
                    this.htmlContent = `<!DOCTYPE html>
<html>
<head>
    <title>Sample Page</title>
</head>
<body>
    <h1>Welcome to My Website</h1>
    <img src="logo.jpg">
    <p style="color: #999; background: #fff;">This is some text with poor contrast.</p>
    <form>
        <input type="text" placeholder="Enter your name">
        <button type="submit">Submit</button>
    </form>
    <div onclick="handleClick()">Clickable div without proper role</div>
</body>
</html>`;
                    
                    // Set up iframe scroll detection after a short delay
                    this.$nextTick(() => {
                        setTimeout(() => {
                            this.setupIframeScrollDetection();
                        }, 100);
                    });
                },

                setupIframeScrollDetection() {
                    const iframe = this.$refs.previewFrame;
                    if (iframe) {
                        // Remove existing listener if any
                        if (this.scrollListener) {
                            iframe.contentWindow?.removeEventListener('scroll', this.scrollListener);
                        }
                        
                        // Create scroll listener to update highlight positions
                        this.scrollListener = () => {
                            // Update highlight positions when user scrolls
                            this.updateHighlightPositions();
                        };
                        
                        // Add scroll listener to iframe content
                        iframe.addEventListener('load', () => {
                            if (iframe.contentWindow) {
                                iframe.contentWindow.addEventListener('scroll', this.scrollListener, { passive: true });
                                iframe.contentDocument.addEventListener('scroll', this.scrollListener, { passive: true });
                            }
                        });
                        
                        // If iframe is already loaded, add listener immediately
                        if (iframe.contentWindow) {
                            iframe.contentWindow.addEventListener('scroll', this.scrollListener, { passive: true });
                            if (iframe.contentDocument) {
                                iframe.contentDocument.addEventListener('scroll', this.scrollListener, { passive: true });
                            }
                        }
                    }
                },

                updateHighlightPositions() {
                    if (this.highlightedElements.length === 0) return;
                    
                    // Update positions for all currently highlighted elements
                    this.highlightedElements = this.highlightedElements.map(highlight => {
                        const iframe = this.$refs.previewFrame;
                        if (!iframe || !iframe.contentDocument) return highlight;
                        
                        try {
                            const element = iframe.contentDocument.querySelector(highlight.selector);
                            if (!element) return highlight; // Keep highlight but mark as unfindable
                            
                            const rect = element.getBoundingClientRect();
                            const iframeHeight = iframe.contentWindow.innerHeight;
                            const iframeWidth = iframe.contentWindow.innerWidth;
                            
                            // Check if element is visible in viewport
                            const isVisible = rect.bottom > 0 && rect.top < iframeHeight &&
                                            rect.right > 0 && rect.left < iframeWidth;
                            
                            // Always update position, but also track visibility
                            const newPosition = this.getElementPosition(highlight.selector);
                            if (newPosition) {
                                return {
                                    ...highlight,
                                    x: newPosition.x,
                                    y: newPosition.y,
                                    width: newPosition.width,
                                    height: newPosition.height,
                                    visible: isVisible // Track visibility state
                                };
                            }
                            
                            // If we can't get position but element exists, mark as invisible
                            return {
                                ...highlight,
                                visible: false
                            };
                        } catch (error) {
                            // Element might not be found, keep highlight but mark as invisible
                            return {
                                ...highlight,
                                visible: false
                            };
                        }
                    });
                },

                showAlertMessage(message, type = 'error') {
                    this.alertMessage = message;
                    this.alertType = type;
                    this.showAlert = true;
                    
                    // Auto-hide after 5 seconds
                    setTimeout(() => {
                        this.showAlert = false;
                    }, 5000);
                },

                async fetchFromUrl() {
                    if (!this.urlInput) return;
                    
                    this.isLoading = true;
                    try {
                        // Note: This is a simplified example. In a real application,
                        // you'd need a backend service to fetch content due to CORS
                        const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(this.urlInput)}`);
                        const data = await response.json();
                        this.htmlContent = data.contents;
                        this.inputMode = 'html';
                    } catch (error) {
                        this.showAlertMessage('Failed to fetch URL. Please try pasting the HTML content directly.', 'error');
                    } finally {
                        this.isLoading = false;
                    }
                },

                analyzeContent() {
                    if (!this.htmlContent) return;
                    
                    this.isLoading = true;
                    
                    // Simulate analysis delay
                    setTimeout(() => {
                        this.runAccessibilityAnalysis();
                        this.updatePreview();
                        this.isLoading = false;
                    }, 1500);
                },

                runAccessibilityAnalysis() {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(this.htmlContent, 'text/html');
                    
                    const issues = [];
                    let score = 100;
                    let criticalCount = 0;
                    let warningCount = 0;
                    let passedCount = 0;

                    // Check for missing alt text
                    const images = doc.querySelectorAll('img');
                    images.forEach((img, index) => {
                        if (!img.hasAttribute('alt') || img.getAttribute('alt').trim() === '') {
                            issues.push({
                                id: `alt-${index}`,
                                rule: 'Images must have alt text',
                                description: 'Image is missing alternative text for screen readers',
                                severity: 'critical',
                                selector: `img:nth-child(${index + 1})`,
                                fix: 'Add alt="descriptive text" attribute to the image',
                                wcagReference: 'https://www.w3.org/WAI/WCAG21/Understanding/non-text-content.html'
                            });
                            criticalCount++;
                            score -= 15;
                        } else {
                            passedCount++;
                        }
                    });

                    // Check heading structure
                    const headings = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
                    let hasH1 = false;
                    headings.forEach((heading, index) => {
                        if (heading.tagName === 'H1') {
                            if (hasH1) {
                                issues.push({
                                    id: `h1-multiple-${index}`,
                                    rule: 'Multiple H1 elements',
                                    description: 'Page should have only one H1 element',
                                    severity: 'warning',
                                    selector: `h1:nth-of-type(${index + 1})`,
                                    fix: 'Use only one H1 element per page, use H2-H6 for subheadings'
                                });
                                warningCount++;
                                score -= 5;
                            }
                            hasH1 = true;
                        }
                    });

                    if (!hasH1) {
                        issues.push({
                            id: 'no-h1',
                            rule: 'Missing H1 element',
                            description: 'Page should have an H1 element',
                            severity: 'critical',
                            selector: 'html',
                            fix: 'Add an H1 element to describe the main content of the page'
                        });
                        criticalCount++;
                        score -= 10;
                    } else {
                        passedCount++;
                    }

                    // Check form labels
                    const inputs = doc.querySelectorAll('input, select, textarea');
                    inputs.forEach((input, index) => {
                        const inputType = input.type ? input.type.toLowerCase() : 'text';
                        const tagName = input.tagName.toLowerCase();
                        const id = input.getAttribute('id');
                        const hasLabel = id && doc.querySelector(`label[for="${id}"]`);
                        const hasAriaLabel = input.hasAttribute('aria-label') || input.hasAttribute('aria-labelledby');
                        
                        // Skip inputs that don't need labels
                        const skipTypes = ['hidden', 'submit', 'reset', 'button', 'image'];
                        
                        if (!skipTypes.includes(inputType) && !hasLabel && !hasAriaLabel) {
                            let selector;
                            let actualIndex;
                            
                            if (tagName === 'input') {
                                // For input elements, filter by type and count only those of the same type
                                const sameTypeInputs = Array.from(doc.querySelectorAll(`input[type="${inputType}"]`));
                                actualIndex = sameTypeInputs.indexOf(input) + 1;
                                selector = `input[type="${inputType}"]:nth-of-type(${actualIndex})`;
                            } else if (tagName === 'select') {
                                // For select elements, count only select elements
                                const selectElements = Array.from(doc.querySelectorAll('select'));
                                actualIndex = selectElements.indexOf(input) + 1;
                                selector = `select:nth-of-type(${actualIndex})`;
                            } else if (tagName === 'textarea') {
                                // For textarea elements, count only textarea elements
                                const textareaElements = Array.from(doc.querySelectorAll('textarea'));
                                actualIndex = textareaElements.indexOf(input) + 1;
                                selector = `textarea:nth-of-type(${actualIndex})`;
                            } else {
                                // Fallback for other elements
                                selector = `${tagName}:nth-of-type(${index + 1})`;
                            }
                            
                            issues.push({
                                id: `label-${index}`,
                                rule: 'Form controls must have labels',
                                description: `${tagName}${tagName === 'input' && inputType !== 'text' ? ` (type="${inputType}")` : ''} field is missing an associated label`,
                                severity: 'critical',
                                selector: selector,
                                fix: `Add a <label> element with for="${id || 'unique-id'}" or add aria-label attribute to describe the ${tagName} field`
                            });
                            criticalCount++;
                            score -= 12;
                        } else if (!skipTypes.includes(inputType)) {
                            passedCount++;
                        }
                    });

                    // Check for interactive elements without proper roles
                    const clickableElements = doc.querySelectorAll('[onclick], [onmousedown], [onmouseup]');
                    clickableElements.forEach((element, index) => {
                        if (element.tagName !== 'BUTTON' && element.tagName !== 'A' && !element.hasAttribute('role')) {
                            // Calculate proper selector for the clickable element
                            const tagName = element.tagName.toLowerCase();
                            const clickableOfSameType = Array.from(doc.querySelectorAll(`${tagName}[onclick], ${tagName}[onmousedown], ${tagName}[onmouseup]`));
                            const elementIndex = clickableOfSameType.indexOf(element) + 1;
                            
                            issues.push({
                                id: `role-${index}`,
                                rule: 'Interactive elements need proper roles',
                                description: `${tagName} element with click handler is not semantically correct for interaction`,
                                severity: 'warning',
                                selector: `${tagName}[onclick]:nth-of-type(${elementIndex})`,
                                fix: `Use <button> or <a> elements instead, or add role="button" and tabindex="0" attributes to make it accessible`
                            });
                            warningCount++;
                            score -= 8;
                        } else {
                            passedCount++;
                        }
                    });

                    // Check for lang attribute
                    const html = doc.documentElement;
                    if (!html.hasAttribute('lang')) {
                        issues.push({
                            id: 'no-lang',
                            rule: 'HTML must have lang attribute',
                            description: 'Page is missing language declaration',
                            severity: 'warning',
                            selector: 'html',
                            fix: 'Add lang="en" (or appropriate language code) to the <html> element'
                        });
                        warningCount++;
                        score -= 5;
                    } else {
                        passedCount++;
                    }

                    // Check for color contrast issues (basic check for inline styles)
                    const elementsWithStyle = doc.querySelectorAll('[style*="color"]');
                    elementsWithStyle.forEach((element, index) => {
                        const style = element.getAttribute('style');
                        // Basic check for potentially poor contrast (light colors)
                        if (style.includes('color: #999') || style.includes('color: #ccc') || style.includes('color: #ddd')) {
                            issues.push({
                                id: `contrast-${index}`,
                                rule: 'Color contrast insufficient',
                                description: 'Text color may not have sufficient contrast ratio',
                                severity: 'warning',
                                selector: `${element.tagName.toLowerCase()}:nth-of-type(${Array.from(doc.querySelectorAll(element.tagName)).indexOf(element) + 1})`,
                                fix: 'Ensure text has a contrast ratio of at least 4.5:1 for normal text and 3:1 for large text'
                            });
                            warningCount++;
                            score -= 8;
                        }
                    });

                    // Check for focus indicators (elements that should be focusable)
                    const interactiveElements = doc.querySelectorAll('a, button, input, select, textarea, [tabindex]');
                    let focusIssues = 0;
                    interactiveElements.forEach((element, index) => {
                        // Check if element has focus styles or outline
                        const style = element.getAttribute('style') || '';
                        if (style.includes('outline: none') || style.includes('outline:none')) {
                            focusIssues++;
                            if (focusIssues <= 2) { // Limit to avoid too many similar issues
                                issues.push({
                                    id: `focus-${index}`,
                                    rule: 'Focus indicators removed',
                                    description: 'Interactive element has focus outline removed without alternative',
                                    severity: 'warning',
                                    selector: `${element.tagName.toLowerCase()}:nth-of-type(${Array.from(doc.querySelectorAll(element.tagName)).indexOf(element) + 1})`,
                                    fix: 'Provide visible focus indicators for keyboard navigation'
                                });
                                warningCount++;
                                score -= 6;
                            }
                        }
                    });

                    // Check for ARIA landmarks
                    const hasMain = doc.querySelector('main') || doc.querySelector('[role="main"]');
                    const hasNav = doc.querySelector('nav') || doc.querySelector('[role="navigation"]');
                    const hasHeader = doc.querySelector('header') || doc.querySelector('[role="banner"]');
                    
                    if (!hasMain) {
                        issues.push({
                            id: 'no-main-landmark',
                            rule: 'Missing main landmark',
                            description: 'Page should have a main landmark for screen readers',
                            severity: 'warning',
                            selector: 'body',
                            fix: 'Add <main> element or role="main" to identify the main content area'
                        });
                        warningCount++;
                        score -= 8;
                    }

                    // Check for keyboard navigation support
                    const clickableWithoutKeyboard = doc.querySelectorAll('[onclick]:not(a):not(button):not([tabindex])');
                    clickableWithoutKeyboard.forEach((element, index) => {
                        if (index < 2) { // Limit similar issues
                            const tagName = element.tagName.toLowerCase();
                            issues.push({
                                id: `keyboard-${index}`,
                                rule: 'Element not keyboard accessible',
                                description: `${tagName} with click handler is not reachable via keyboard`,
                                severity: 'critical',
                                selector: `${tagName}[onclick]:nth-of-type(${Array.from(doc.querySelectorAll(`${tagName}[onclick]`)).indexOf(element) + 1})`,
                                fix: 'Add tabindex="0" and keyboard event handlers, or use button/a elements instead'
                            });
                            criticalCount++;
                            score -= 12;
                        }
                    });

                    // Update WCAG checklist
                    this.wcagChecklist.forEach(check => {
                        switch (check.id) {
                            case 'alt-text':
                                check.passed = !issues.some(issue => issue.rule.includes('alt text'));
                                break;
                            case 'headings':
                                check.passed = !issues.some(issue => issue.rule.includes('H1'));
                                break;
                            case 'contrast':
                                check.passed = !issues.some(issue => issue.rule.includes('contrast'));
                                break;
                            case 'keyboard':
                                check.passed = !issues.some(issue => issue.rule.includes('keyboard') || issue.rule.includes('role'));
                                break;
                            case 'landmarks':
                                check.passed = !issues.some(issue => issue.rule.includes('landmark'));
                                break;
                            case 'form-labels':
                                check.passed = !issues.some(issue => issue.rule.includes('labels'));
                                break;
                            case 'focus-visible':
                                check.passed = !issues.some(issue => issue.rule.includes('focus'));
                                break;
                            case 'lang-attribute':
                                check.passed = !issues.some(issue => issue.rule.includes('lang'));
                                break;
                        }
                    });

                    this.report = {
                        score: Math.max(0, Math.round(score)),
                        issues: {
                            critical: criticalCount,
                            warnings: warningCount,
                            passed: passedCount
                        },
                        detailedIssues: issues
                    };
                },

                updatePreview() {
                    this.previewContent = this.htmlContent;
                    this.$nextTick(() => {
                        if (this.$refs.previewFrame) {
                            this.$refs.previewFrame.srcdoc = this.htmlContent;
                            // Set up scroll detection after iframe loads
                            setTimeout(() => {
                                this.setupIframeScrollDetection();
                            }, 200);
                        }
                    });
                },

                onIframeLoad() {
                    try {
                        this.iframeDocument = this.$refs.previewFrame.contentDocument;
                        console.log('Iframe loaded and document accessible');
                        // Set up scroll detection
                        this.setupIframeScrollDetection();
                    } catch (error) {
                        console.warn('Cannot access iframe document due to security restrictions');
                        this.iframeDocument = null;
                    }
                },

                getElementPosition(selector) {
                    if (!this.iframeDocument) {
                        console.warn('Iframe document not accessible');
                        return null;
                    }

                    try {
                        // Try to find element with various selector strategies
                        let element = null;
                        
                        // Try direct selector first
                        try {
                            element = this.iframeDocument.querySelector(selector);
                        } catch (e) {
                            console.warn('Invalid selector:', selector);
                        }

                        // Fallback strategies for common selectors
                        if (!element) {
                            if (selector.includes('img')) {
                                const imgs = this.iframeDocument.querySelectorAll('img');
                                const match = selector.match(/nth-child\((\d+)\)/);
                                if (match && imgs[parseInt(match[1]) - 1]) {
                                    element = imgs[parseInt(match[1]) - 1];
                                }
                            } else if (selector.includes('input')) {
                                // Handle different input selector patterns
                                if (selector.includes('type=')) {
                                    // Extract type and index from selector like input[type="text"]:nth-of-type(1)
                                    const typeMatch = selector.match(/type="([^"]+)"/);
                                    const indexMatch = selector.match(/nth-of-type\((\d+)\)/);
                                    if (typeMatch && indexMatch) {
                                        const type = typeMatch[1];
                                        const index = parseInt(indexMatch[1]) - 1;
                                        const inputs = this.iframeDocument.querySelectorAll(`input[type="${type}"]`);
                                        if (inputs[index]) {
                                            element = inputs[index];
                                        }
                                    }
                                } else {
                                    // Fallback to generic input selector
                                    const inputs = this.iframeDocument.querySelectorAll('input');
                                    const match = selector.match(/nth-of-type\((\d+)\)/);
                                    if (match && inputs[parseInt(match[1]) - 1]) {
                                        element = inputs[parseInt(match[1]) - 1];
                                    }
                                }
                            } else if (selector.includes('textarea')) {
                                const textareas = this.iframeDocument.querySelectorAll('textarea');
                                const match = selector.match(/nth-of-type\((\d+)\)/);
                                if (match && textareas[parseInt(match[1]) - 1]) {
                                    element = textareas[parseInt(match[1]) - 1];
                                }
                            } else if (selector.includes('select')) {
                                const selects = this.iframeDocument.querySelectorAll('select');
                                const match = selector.match(/nth-of-type\((\d+)\)/);
                                if (match && selects[parseInt(match[1]) - 1]) {
                                    element = selects[parseInt(match[1]) - 1];
                                }
                            } else if (selector.includes('h1')) {
                                const h1s = this.iframeDocument.querySelectorAll('h1');
                                if (h1s.length > 0) {
                                    element = h1s[0];
                                }
                            } else if (selector === 'html') {
                                element = this.iframeDocument.documentElement;
                            }
                        }

                        if (!element) {
                            console.warn('Element not found for selector:', selector);
                            return null;
                        }

                        const rect = element.getBoundingClientRect();
                        const iframeRect = this.$refs.previewFrame.getBoundingClientRect();
                        
                        return {
                            x: rect.left,
                            y: rect.top,
                            width: rect.width || 20, // Minimum width for visibility
                            height: rect.height || 20 // Minimum height for visibility
                        };
                    } catch (error) {
                        console.error('Error getting element position:', error);
                        return null;
                    }
                },

                getScoreColor(score) {
                    if (score >= 80) return 'text-green-500';
                    if (score >= 60) return 'text-yellow-500';
                    return 'text-red-500';
                },

                getSeverityBadge(severity) {
                    switch (severity) {
                        case 'critical': return 'badge-error';
                        case 'warning': return 'badge-warning';
                        default: return 'badge-info';
                    }
                },

                showIssueDetail(issue) {
                    this.selectedIssue = issue;
                },

                highlightElement(issue) {
                    console.log('Highlighting element:', issue.selector);
                    
                    // Wait for iframe to be ready
                    this.$nextTick(() => {
                        setTimeout(() => {
                            const iframe = this.$refs.previewFrame;
                            if (!iframe || !iframe.contentDocument) return;
                            
                            try {
                                const element = iframe.contentDocument.querySelector(issue.selector);
                                if (element) {
                                    // Check if element is already visible in viewport
                                    const rect = element.getBoundingClientRect();
                                    const iframeWindow = iframe.contentWindow;
                                    const isVisible = rect.top >= 0 && 
                                                    rect.left >= 0 && 
                                                    rect.bottom <= iframeWindow.innerHeight && 
                                                    rect.right <= iframeWindow.innerWidth;
                                    
                                    const highlightElementNow = () => {
                                        const position = this.getElementPosition(issue.selector);
                                        
                                        if (position) {
                                            const highlight = {
                                                id: issue.id,
                                                x: position.x,
                                                y: position.y,
                                                width: position.width,
                                                height: position.height,
                                                issue: issue.rule,
                                                selector: issue.selector,
                                                visible: true // Initially visible since we're highlighting it
                                            };
                                            
                                            // Remove existing highlight for this element
                                            this.highlightedElements = this.highlightedElements.filter(h => h.id !== issue.id);
                                            
                                            // Add new highlight
                                            this.highlightedElements.push(highlight);
                                            
                                            console.log('Element highlighted:', highlight);
                                        }
                                    };
                                    
                                    if (isVisible) {
                                        // Element is already visible, highlight immediately
                                        highlightElementNow();
                                    } else {
                                        // Need to scroll, set up intersection observer for immediate highlighting
                                        const observer = new IntersectionObserver((entries) => {
                                            entries.forEach(entry => {
                                                if (entry.isIntersecting) {
                                                    // Element is now visible, highlight immediately
                                                    highlightElementNow();
                                                    observer.disconnect();
                                                }
                                            });
                                        }, {
                                            root: null,
                                            rootMargin: '0px',
                                            threshold: 0.1 // Trigger when at least 10% of element is visible
                                        });
                                        
                                        observer.observe(element);
                                        
                                        // Scroll to element
                                        element.scrollIntoView({ 
                                            behavior: 'smooth', 
                                            block: 'center',
                                            inline: 'center'
                                        });
                                        
                                        // Fallback timeout in case intersection observer doesn't work
                                        setTimeout(() => {
                                            observer.disconnect();
                                            highlightElementNow();
                                        }, 1000);
                                    }
                                }
                            } catch (error) {
                                console.error('Error highlighting element:', error);
                                // Fallback to existing position-based highlighting
                                const position = this.getElementPosition(issue.selector);
                                
                                if (position) {
                                    const highlight = {
                                        id: issue.id,
                                        x: position.x,
                                        y: position.y,
                                        width: position.width,
                                        height: position.height,
                                        issue: issue.rule,
                                        selector: issue.selector,
                                        visible: true // Initially visible
                                    };
                                    
                                    // Remove existing highlight for this element
                                    this.highlightedElements = this.highlightedElements.filter(h => h.id !== issue.id);
                                    
                                    // Add new highlight
                                    this.highlightedElements.push(highlight);
                                    
                                    console.log('Element highlighted:', highlight);
                                } else {
                                    // Show notification if element cannot be found
                                    this.showAlertMessage(`Cannot highlight element "${issue.selector}" - it may not be visible in the preview. Issue: ${issue.rule}`, 'warning');
                                }
                            }
                        }, 100); // Small delay to ensure iframe content is rendered
                    });
                },

                highlightAllIssues() {
                    if (!this.report?.detailedIssues?.length) return;
                    
                    console.log('Highlighting all issues');
                    this.clearHighlights();
                    
                    // Use a more reliable approach for highlighting all issues
                    this.report.detailedIssues.forEach((issue, index) => {
                        setTimeout(() => {
                            const iframe = this.$refs.previewFrame;
                            if (!iframe || !iframe.contentDocument) return;
                            
                            try {
                                const element = iframe.contentDocument.querySelector(issue.selector);
                                if (element) {
                                    // For "highlight all", we don't need to scroll, just highlight directly
                                    const position = this.getElementPosition(issue.selector);
                                    
                                    if (position) {
                                        // Check if element is currently visible
                                        const rect = element.getBoundingClientRect();
                                        const iframeHeight = iframe.contentWindow.innerHeight;
                                        const iframeWidth = iframe.contentWindow.innerWidth;
                                        const isVisible = rect.bottom > 0 && rect.top < iframeHeight &&
                                                        rect.right > 0 && rect.left < iframeWidth;
                                        
                                        const highlight = {
                                            id: issue.id,
                                            x: position.x,
                                            y: position.y,
                                            width: position.width,
                                            height: position.height,
                                            issue: issue.rule,
                                            selector: issue.selector,
                                            visible: isVisible // Set visibility based on current viewport
                                        };
                                        
                                        // Remove existing highlight for this element
                                        this.highlightedElements = this.highlightedElements.filter(h => h.id !== issue.id);
                                        
                                        // Add new highlight
                                        this.highlightedElements.push(highlight);
                                        
                                        console.log('Element highlighted (all):', highlight);
                                    }
                                } else {
                                    // Element exists in DOM but might be out of view - add it anyway
                                    const highlight = {
                                        id: issue.id,
                                        x: 0,
                                        y: 0,
                                        width: 0,
                                        height: 0,
                                        issue: issue.rule,
                                        selector: issue.selector,
                                        visible: false // Not visible initially
                                    };
                                    
                                    // Remove existing highlight for this element
                                    this.highlightedElements = this.highlightedElements.filter(h => h.id !== issue.id);
                                    
                                    // Add new highlight
                                    this.highlightedElements.push(highlight);
                                }
                            } catch (error) {
                                console.error('Error highlighting element in highlightAllIssues:', error);
                            }
                        }, index * 50); // Reduced delay for faster highlighting
                    });
                },

                clearHighlights() {
                    this.highlightedElements = [];
                    console.log('All highlights cleared');
                },

                toggleOverlay() {
                    // Legacy method - now redirects to clear highlights
                    if (this.highlightedElements.length > 0) {
                        this.clearHighlights();
                    } else {
                        this.highlightAllIssues();
                    }
                },

                exportReport() {
                    const reportData = {
                        timestamp: new Date().toISOString(),
                        score: this.report.score,
                        summary: this.report.issues,
                        issues: this.report.detailedIssues,
                        wcagChecklist: this.wcagChecklist
                    };

                    const blob = new Blob([JSON.stringify(reportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `accessibility-report-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
        }
    </script>
</body>
</html>
